#include "libc.ika"
#include "tier0.ika"
#include "tier1.ika"
#include "mem.ika"

var g_pServerPluginHandler: *void = null;

var CServerPlugin__LoadPlugin: fn "thiscall" (thisptr: *void, fileName: []u8) bool;

fn hooked_plugin_load_fn(args: *CCommand) void {
    if (args.m_nArgc < 2) {
        Warning("plugin_load <filename>\n");
    } else {
        if (!CServerPlugin__LoadPlugin(g_pServerPluginHandler, args.m_ppArgv[1])) {
            Warning("Unable to load plugin \"%s\"\n", args.m_ppArgv[1]);
            return;
        }
        Msg("Loaded plugin \"%s\"\n", args.m_ppArgv[1]);
    }
}

var is_loaded: bool = false;
var skip_unload: bool = false;

var plugin_load: *ConCommand;
var orig_plugin_load_fn: *void = null;

fn "thiscall" Load(
    thisptr: *void,
    interfaceFactory: fn(name: []u8, ret: *i32) *void,
    gameServerFactory: fn(name: []u8, ret: *i32) *void
) bool {
    if (is_loaded) {
        Warning("Plugin already loaded\n");
        skip_unload = true;
        return false;
    }

    g_pCVar = interfaceFactory("VEngineCvar004", null);
    if (g_pCVar == null) {
        Warning("Failed to get ICvar interface\n");
        return false;
    }

    g_pServerPluginHandler = interfaceFactory("ISERVERPLUGINHELPERS001", null);
    if (g_pServerPluginHandler == null) {
        Warning("Failed to get IServerPluginHelpers interface\n");
        return false;
    }

    plugin_load = g_pCVar._vt.FindCommand(g_pCVar, "plugin_load");
    if (plugin_load == null) {
        Warning("Failed to find plugin_load\n");
        return false;
    }

    var plugin_load_fn: []u8 = as([]u8, plugin_load.m_fnCompletionCallback);
    if (plugin_load_fn[0] != 0xc3) {
        Msg("No need to fix! plugin_load callback is not no-op\n");
        return false;
    }

    var mem: []u8;
    var len: u32;
    if (!GetModule("engine.dll", &mem, &len)) {
        Warning("Failed to open engine.dll\n");
        return false;
    }

    const pattern = "\x55\x8B\xEC\x51\x56\x57\x68\x90\x00\x00\x00";
    const pattern_len = 11;
    var offset: u32;
    if (!ScanUnique(mem, len, pattern, pattern_len, &offset)) {
        Warning("Failed to find CServerPlugin::LoadPlugin\n");
        return false;
    }

    CServerPlugin__LoadPlugin = as(*void, mem + offset);
    orig_plugin_load_fn = plugin_load.m_fnCompletionCallback;
    plugin_load.m_fnCompletionCallback = hooked_plugin_load_fn;

    is_loaded = true;
    return true;
}

fn "thiscall" Unload(thisptr: *void) void {
    if (skip_unload) {
        skip_unload = false;
        return;
    }

    if (orig_plugin_load_fn != null) {
        plugin_load.m_fnCompletionCallback = orig_plugin_load_fn;
        orig_plugin_load_fn = null;
    }
}

fn "thiscall" Pause(thisptr: *void) void {}

fn "thiscall" UnPause(thisptr: *void) void {}

fn "thiscall" GetPluginDescription(thisptr: *void) []u8 {
    return "plugin_load fix";
}

fn "thiscall" LevelInit(thisptr: *void, pMapName: []u8) void {}

fn "thiscall" ServerActivate(
    thisptr: *void,
    pEdictList: *void,
    edictCount: i32,
    clientMax: i32
) void {}

fn "thiscall" GameFrame(thisptr: *void, simulating: bool) void {}

fn "thiscall" LevelShutdown(thisptr: *void) void {}

fn "thiscall" ClientActive(thisptr: *void, pEntity: *void) void {}

fn "thiscall" ClientDisconnect(thisptr: *void, pEntity: *void) void {}

fn "thiscall" ClientPutInServer(thisptr: *void, pEntity: *void, playername: []u8) void {}

fn "thiscall" SetCommandClient(thisptr: *void, index: i32) void {}

fn "thiscall" ClientSettingsChanged(thisptr: *void, pEdict: *void) void {}

fn "thiscall" ClientConnect(
    thisptr: *void,
    bAllowConnect: *bool,
    pEntity: *void,
    pszName: []u8,
    pszAddress: []u8,
    reject: []u8,
    maxrejectlen: i32
) i32 {
    return 0;
}

fn "thiscall" ClientCommand(
    thisptr: *void,
    pEntity: *void,
    args: *void
) i32 {
    return 0;
}

fn "thiscall" NetworkIDValidated(
    thisptr: *void,
    pszUserName: []u8,
    pszNetworkID: []u8
) i32 {
    return 0;
}

fn "thiscall" OnQueryCvarValueFinished(
    thisptr: *void,
    iCookie: i32,
    pPlayerEntity: *void,
    eStatus: i32,
    pCvarName: []u8,
    pCvarValue: []u8
) void {}

fn "thiscall" OnEdictAllocated(thisptr: *void, edict: *void) void {}

fn "thiscall" OnEdictFreed(thisptr: *void, edict: *void) void {}

const VT_PLUGIN_COUNT = 20;

var _vt_plugin: [VT_PLUGIN_COUNT]*void;

struct IServerPluginCallbacks {
    _vt: *[VT_PLUGIN_COUNT]*void
};

var plugin: IServerPluginCallbacks;

fn InitPluginVT() void {
    _vt_plugin[0] = Load;
    _vt_plugin[1] = Unload;
    _vt_plugin[2] = Pause;
    _vt_plugin[3] = UnPause;
    _vt_plugin[4] = GetPluginDescription;
    _vt_plugin[5] = LevelInit;
    _vt_plugin[6] = ServerActivate;
    _vt_plugin[7] = GameFrame;
    _vt_plugin[8] = LevelShutdown;
    _vt_plugin[9] = ClientActive;
    _vt_plugin[10] = ClientDisconnect;
    _vt_plugin[11] = ClientPutInServer;
    _vt_plugin[12] = SetCommandClient;
    _vt_plugin[13] = ClientSettingsChanged;
    _vt_plugin[14] = ClientConnect;
    _vt_plugin[15] = ClientCommand;
    _vt_plugin[16] = NetworkIDValidated;
    _vt_plugin[17] = OnQueryCvarValueFinished;
    _vt_plugin[18] = OnEdictAllocated;
    _vt_plugin[19] = OnEdictFreed;

    plugin._vt = &_vt_plugin;
}

fn CreateInterface(pName: []u8, pReturncode: *i32) *IServerPluginCallbacks {
    if (strcmp(pName, "ISERVERPLUGINCALLBACKS003") == 0) {
        InitPluginVT();
        if (pReturncode != null) {
            *pReturncode = 0;
        }
        return &plugin;
    }

    if (pReturncode != null) {
        *pReturncode = 1;
    }
    return null;
}

fn "stdcall" DllMain(hinstDLL: *void, fdwReason: u32, lpReserved: *void) bool {
    return true;
}
